use thiserror::Error;

#[derive(Error, Debug, PartialEq, Eq, Clone)]
pub enum UnicodeError {
    #[error("input contains zero-width or non-visible formatting characters")] ZeroWidthCharacter,
    #[error("input contains bidirectional control characters")] BidirectionalControlCharacter,
}

pub fn check_for_confusables(input: &str) -> Result<(), UnicodeError> {
    for c in input.chars() {
        match c {
            '\u{200B}'..='\u{200F}' | '\u{2060}'..='\u{206F}' | '\u{FEFF}' => return Err(UnicodeError::ZeroWidthCharacter),
            '\u{202A}'..='\u{202E}' => return Err(UnicodeError::BidirectionalControlCharacter),
            _ => {}
        }
    }
    Ok(())
}
