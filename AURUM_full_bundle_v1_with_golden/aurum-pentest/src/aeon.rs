use flate2::write::GzEncoder; use flate2::Compression; use std::collections::HashMap; use std::io::Write;
pub fn calculate_h_norm(data: &[u8]) -> f64 { if data.is_empty(){return 0.0;} let mut counts=HashMap::new(); for b in data{*counts.entry(*b).or_insert(0usize)+=1;} let n=data.len() as f64; let mut h=0.0; for (_b,c) in counts{let p=(c as f64)/n; h += -p*p.log2();} let sigma=256.0_f64; h/sigma.log2() }
pub fn calculate_t_star(data: &[u8]) -> f64 { let h_norm=calculate_h_norm(data); let mut enc=GzEncoder::new(Vec::new(), Compression::default()); let _=enc.write_all(data); let gz=enc.finish().unwrap_or_default(); let comp_ratio= if data.is_empty(){0.0}else{1.0 - (gz.len() as f64 / data.len() as f64)}; ((h_norm+comp_ratio)/2.0).clamp(0.0,1.0) }
