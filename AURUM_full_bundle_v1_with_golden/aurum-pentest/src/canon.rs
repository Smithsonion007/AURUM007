use serde_json::Error as SerdeError;
use thiserror::Error;
use crate::utils::unicode::{check_for_confusables, UnicodeError};

#[derive(Debug, Error)]
pub enum CanonErr { #[error("invalid amount (must be > 0)")] InvalidNum, #[error("unicode validation failed: {0}")] Unicode(#[from] UnicodeError), #[error("serde error: {0}")] Serde(#[from] SerdeError) }

fn json_escape(s: &str) -> String { s.replace('\\', r"\\").replace('"', r#"\""#) }

fn check_ranges(amount: u128, _fee: u128) -> Result<(), CanonErr> { if amount == 0 { return Err(CanonErr::InvalidNum); } Ok(()) }

pub fn canonical_tx_bytes(version: u32, from: &str, to: &str, amount: u128, fee: u128, nonce: u64) -> Result<Vec<u8>, CanonErr> {
    check_ranges(amount, fee)?; check_for_confusables(from)?; check_for_confusables(to)?;
    let json_string = format!(r#"{{"v":{},"from":"{}","to":"{}","amount":"{}","fee":"{}","nonce":{}}}"#, version, json_escape(from), json_escape(to), amount, fee, nonce);
    Ok(json_string.into_bytes())
}
