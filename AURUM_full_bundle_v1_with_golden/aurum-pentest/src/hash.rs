use blake3::{hash, Hasher};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum DsError { #[error("invalid domain separation tag")] InvalidDst }

const VALID_DST: &[&str] = &[
    "AURUM/Tx","AURUM/Block","AURUM/StateLeaf","AURUM/MerkleNode","AURUM/MerkleEmpty",
    "AURUM/VRFInput/v1","AURUM/Receipt","AURUM/Note","AURUM/AIAudit/Output","AURUM/AIAudit/ModelProof",
];

fn derive_key_from_dst(dst: &str) -> [u8;32] { *hash(dst.as_bytes()).as_bytes() }

pub fn blake3_ds(dst: &str, bytes: &[u8]) -> Result<[u8;32], DsError> {
    if !VALID_DST.contains(&dst) { return Err(DsError::InvalidDst); }
    let key = derive_key_from_dst(dst);
    let mut h = Hasher::new_keyed(&key);
    h.update(bytes);
    Ok(*h.finalize().as_bytes())
}
