use std::collections::HashMap;

use blake3::{hash, Hasher};
use once_cell::sync::Lazy;
use thiserror::Error;

#[derive(Debug, Error)]
pub enum DsError {
    #[error("invalid domain separation tag")]
    InvalidDst,
}

const VALID_DST: &[&str] = &[
    "AURUM/Tx",
    "AURUM/Block",
    "AURUM/StateLeaf",
    "AURUM/MerkleNode",
    "AURUM/MerkleEmpty",
    "AURUM/VRFInput/v1",
    "AURUM/Receipt",
    "AURUM/Note",
    "AURUM/AIAudit/Output",
    "AURUM/AIAudit/ModelProof",
];

static DST_KEYS: Lazy<HashMap<&'static str, [u8; 32]>> = Lazy::new(|| {
    let mut map = HashMap::with_capacity(VALID_DST.len());
    for &dst in VALID_DST {
        map.insert(dst, *hash(dst.as_bytes()).as_bytes());
    }
    map
});

fn keyed_hasher(dst: &str) -> Result<Hasher, DsError> {
    match DST_KEYS.get(dst) {
        Some(key) => Ok(Hasher::new_keyed(key)),
        None => Err(DsError::InvalidDst),
    }
}

#[inline]
pub fn blake3_ds(dst: &str, bytes: &[u8]) -> Result<[u8; 32], DsError> {
    blake3_ds_multi(dst, std::iter::once(bytes))
}

#[inline]
pub fn blake3_ds_multi<'a>(
    dst: &str,
    parts: impl IntoIterator<Item = &'a [u8]>,
) -> Result<[u8; 32], DsError> {
    let mut hasher = keyed_hasher(dst)?;
    for part in parts {
        hasher.update(part);
    }
    Ok(*hasher.finalize().as_bytes())
}
