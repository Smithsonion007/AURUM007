use crate::hash::{blake3_ds, DsError};

pub fn leaf_hash(value: &[u8]) -> Result<[u8;32], DsError> { blake3_ds("AURUM/StateLeaf", value) }

fn parent_hash(left: [u8;32], right: [u8;32]) -> Result<[u8;32], DsError> { let mut buf=[0u8;64]; buf[..32].copy_from_slice(&left); buf[32..].copy_from_slice(&right); blake3_ds("AURUM/MerkleNode", &buf) }

pub fn empty_root() -> Result<[u8;32], DsError> { blake3_ds("AURUM/MerkleEmpty", b"") }

pub fn merkle_root(raw_leaves: &[&[u8]]) -> Result<[u8;32], DsError> {
    if raw_leaves.is_empty() { return empty_root(); }
    let mut leaves: Vec<[u8;32]> = raw_leaves.iter().map(|v| leaf_hash(v)).collect::<Result<Vec<_>,_>>()?;
    while leaves.len()>1 { let mut next=Vec::with_capacity((leaves.len()+1)/2); for pair in leaves.chunks(2) { let h= if pair.len()==2 { parent_hash(pair[0],pair[1])? } else { parent_hash(pair[0],pair[0])? }; next.push(h);} leaves=next; }
    Ok(leaves[0])
}
