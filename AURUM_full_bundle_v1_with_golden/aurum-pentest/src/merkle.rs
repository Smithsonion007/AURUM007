use crate::hash::{blake3_ds, blake3_ds_multi, DsError};

pub fn leaf_hash(value: &[u8]) -> Result<[u8; 32], DsError> {
    blake3_ds("AURUM/StateLeaf", value)
}

fn parent_hash(left: &[u8; 32], right: &[u8; 32]) -> Result<[u8; 32], DsError> {
    blake3_ds_multi("AURUM/MerkleNode", [left.as_ref(), right.as_ref()])
}

pub fn empty_root() -> Result<[u8; 32], DsError> {
    blake3_ds("AURUM/MerkleEmpty", b"")
}

pub fn merkle_root(raw_leaves: &[&[u8]]) -> Result<[u8; 32], DsError> {
    if raw_leaves.is_empty() {
        return empty_root();
    }

    let mut leaves: Vec<[u8; 32]> = raw_leaves
        .iter()
        .map(|value| leaf_hash(value))
        .collect::<Result<Vec<_>, _>>()?;

    let mut level_len = leaves.len();
    while level_len > 1 {
        let mut write_idx = 0;
        let mut read_idx = 0;
        while read_idx < level_len {
            let left = &leaves[read_idx];
            let right = if read_idx + 1 < level_len {
                &leaves[read_idx + 1]
            } else {
                left
            };
            leaves[write_idx] = parent_hash(left, right)?;
            write_idx += 1;
            read_idx += 2;
        }
        level_len = write_idx;
    }

    Ok(leaves[0])
}
